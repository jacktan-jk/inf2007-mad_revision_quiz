<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>INF2007 – Code Blocks MCQ Quiz</title>
  <style>
    :root { --maxw: 980px; --accent: #0f766e; --muted:#6b7280; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial,
    "Noto Sans", sans-serif; line-height: 1.45; margin: 0; background: #f7f7f8;
    color:#111827; }
    header { background: white; border-bottom: 1px solid #e5e7eb; }
    .wrap { max-width: var(--maxw); margin: 0 auto; padding: 18px 16px; }
    h1 { font-size: clamp(20px, 2.6vw, 28px); margin: 0 0 6px; }
    .sub { color: var(--muted); font-size: 14px; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px }
    button { cursor:pointer; border:1px solid #e5e7eb; background:white;
    padding:8px 12px; border-radius:10px; font-weight:600; }
    button.primary { background: var(--accent); color: white; border-color:
    var(--accent); }
    button:disabled { opacity:.6; cursor:not-allowed }
    .stats { display:flex; gap:18px; align-items:center; margin-top:10px; }
    .pill { background:#eef2ff; color:#3730a3; font-weight:700; padding:6px
    10px; border-radius:999px; }
    main { max-width: var(--maxw); margin: 12px auto 60px; padding: 0 16px; }
    .qcard { background:white; border:1px solid #e5e7eb; border-radius:14px;
    padding:14px; margin:14px 0; box-shadow: 0 1px 0 rgba(0,0,0,.03); }
    .qhead { display:flex; justify-content:space-between; align-items:baseline;
    gap:6px }
    .qtitle { font-weight:700; margin:0 0 8px }
    .badge { font-size:12px; color:#374151; background:#f3f4f6; border:1px
    solid #e5e7eb; padding:2px 8px; border-radius:999px }
    .opts { display:grid; gap:8px; margin-top:8px }
    .opt { display:flex; gap:10px; align-items:flex-start; padding:10px;
    border:1px solid #e5e7eb; border-radius:12px; background:white; cursor:pointer; }
    .opt:hover { border-color:#c7d2fe; }
    .opt.correct { border-color:#16a34a; background:#f0fdf4; }
    .opt.wrong { border-color:#dc2626; background:#fef2f2; }
    .opt.disabled { pointer-events:none; opacity:.8 }
    .letter { width:28px; height:28px; border-radius:999px; border:1px
    solid #e5e7eb; display:grid; place-items:center; font-weight:700; }
    .exp { margin-top:10px; border-top:1px dashed #e5e7eb; padding-top:10px;
    color:#111827; }
    .exp strong { color:#065f46 }
    /* Code block styling: dark background and monospace font */
    pre.code-block {
      background-color: #1e293b;
      color: #f8fafc;
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      margin: 12px 0;
    }
    footer { text-align:center; color:#6b7280; padding:30px 12px; }
    details > summary { cursor:pointer; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>INF2007 – Code Blocks MCQ Quiz</h1>
      <div class="sub">INF2007 – Mobile Application Development • Code practice</div>
      <div class="stats" id="stats">
        <span class="pill" id="score">Score: 0</span>
        <span class="pill" id="progress">Answered: 0 / 0</span>
        <span class="pill" id="percent">0%</span>
      </div>
      <div class="controls">
        <button class="primary" id="resetBtn" title="Reset the quiz to try again">Reset quiz</button>
        <button id="revealBtn" title="Reveal correct answers for all questions">Reveal all answers</button>
        <button id="shuffleBtn" title="Shuffle questions and answer options">Shuffle</button>
      </div>
    </div>
  </header>
  <main id="quiz"></main>
  <footer>
    Based on lecture material. This educational quiz is for practice.
  </footer>
  <script>
    const QUESTIONS = [
  {
    "q": "<pre class=\"code-block\">1  fun main() {\n2      var x = 10\n3      x += 5\n4      val y = x\n5      println(y)\n6  }</pre>\nWhat is printed by this Kotlin program?",
    "options": [
      "10",
      "15",
      "5",
      "Compilation error"
    ],
    "correct": 1,
    "why": "[Line 2] declares var x = 10. [Line 3] adds 5 to x (x += 5), making it 15. [Line 4] assigns this value to val y. [Line 5] prints y, which is 15."
  },
  {
    "q": "<pre class=\"code-block\">1  fun safeLength(str: String?): Int {\n2      return str?.length ?: 0\n3  }\n4  fun main() {\n5      val name: String? = null\n6      println(safeLength(name))\n7  }</pre>\nWhat is printed when this code runs?",
    "options": [
      "0",
      "null",
      "Compilation error",
      "Throws NullPointerException"
    ],
    "correct": 0,
    "why": "[Line 5] sets name to null. [Line 6] calls safeLength(null). In [line 2], the safe call (?.) returns null and the Elvis operator (?:) returns 0, so 0 is printed."
  },
  {
    "q": "<pre class=\"code-block\">1  fun evaluate(n: Int): String {\n2      return when (n) {\n3          1 -> \"One\"\n4          2 -> \"Two\"\n5          else -> \"Other\"\n6      }\n7  }\n8  fun main() {\n9      println(evaluate(2))\n10 }</pre>\nWhat does this program print?",
    "options": [
      "One",
      "Two",
      "Other",
      "Compilation error"
    ],
    "correct": 1,
    "why": "[Line 9] calls evaluate(2). In the when expression ([lines 2-6]), [line 4] matches n == 2 and returns \"Two\"."
  },
  {
    "q": "<pre class=\"code-block\">1  fun main() {\n2      val sum: (Int, Int) -> Int = { a, b -> a + b }\n3      println(sum(3, 4))\n4  }</pre>\nWhat is printed by this code?",
    "options": [
      "7",
      "3",
      "4",
      "Compilation error"
    ],
    "correct": 0,
    "why": "[Line 2] defines a lambda that takes two Ints and returns their sum. [Line 3] calls sum(3, 4), which evaluates to 3 + 4 = 7."
  },
  {
    "q": "<pre class=\"code-block\">1  class BankAccount(private var balance: Int) {\n2      fun deposit(amount: Int) {\n3          balance += amount\n4      }\n5      fun getBalance(): Int = balance\n6  }\n7  fun main() {\n8      val account = BankAccount(100)\n9      account.deposit(50)\n10     println(account.getBalance())\n11 }</pre>\nWhat value is printed?",
    "options": [
      "100",
      "50",
      "150",
      "Compilation error"
    ],
    "correct": 2,
    "why": "[Line 8] creates an account with balance = 100. [Line 9] calls deposit(50), and [line 3] adds 50 to balance (100 + 50 = 150). [Line 10] prints getBalance() which returns 150 ([line 5])."
  },
  {
    "q": "<pre class=\"code-block\">1  fun main() {\n2      val text: String? = \"Compose\"\n3      text?.let {\n4          println(it.uppercase())\n5      }\n6  }</pre>\nWhat is printed by this program?",
    "options": [
      "compose",
      "COMPOSE",
      "null",
      "Nothing is printed"
    ],
    "correct": 1,
    "why": "[Line 2] sets text to \"Compose\" (non-null). [Line 3] uses safe call (?.) with let, which executes since text is not null. [Line 4] prints it.uppercase(), converting \"Compose\" to \"COMPOSE\"."
  },
  {
    "q": "<pre class=\"code-block\">1  val intent = Intent(this, ProfileActivity::class.java)\n2  startActivity(intent)</pre>\nWhat does this code do in an Android Activity?",
    "options": [
      "It starts ProfileActivity",
      "It sends a broadcast",
      "It binds a service",
      "It registers a ContentProvider"
    ],
    "correct": 0,
    "why": "[Line 1] creates an explicit Intent targeting ProfileActivity. [Line 2] calls startActivity() which launches the ProfileActivity."
  },
  {
    "q": "<pre class=\"code-block\">1  val intentFilter = IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED)\n2  val receiver = object : BroadcastReceiver() {\n3      override fun onReceive(context: Context, intent: Intent?) {\n4          println(\"Airplane mode changed\")\n5      }\n6  }\n7  registerReceiver(receiver, intentFilter)</pre>\nWhich component listens for the airplane mode change?",
    "options": [
      "Activity",
      "Service",
      "BroadcastReceiver",
      "ContentProvider"
    ],
    "correct": 2,
    "why": "[Line 2] creates an anonymous BroadcastReceiver object. [Line 3] overrides onReceive() which will be called when the airplane mode changes. [Line 7] registers this receiver to listen for the intent filter created in [line 1]."
  },
  {
    "q": "<pre class=\"code-block\">1  fun marking(homework: String, compute: () -> Int) {\n2      println(\"$homework result:\")\n3      val result = compute()\n4      println(if (result >= 50) \"You pass!\" else \"You fail!\")\n5  }\n6  fun main() {\n7      marking(\"Lab 1\") {\n8          val q1 = 4\n9          val q2 = 1\n10         (q1 + q2) * 10 // Return value implicitly\n11     }\n12 }</pre>\nWhat does this program output?",
    "options": [
      "error",
      "Lab 1 result:\nYou fail!",
      "Lab 1 result:\nYou pass!",
      "You pass!"
    ],
    "correct": 2,
    "why": "[Line 7] calls marking with a lambda. [Line 2] prints \"Lab 1 result:\". [Line 3] executes the lambda: [lines 8-10] compute (4+1)*10 = 50. [Line 4] checks if 50 >= 50 (true) and prints \"You pass!\"."
  },
  {
    "q": "<pre class=\"code-block\">1  fun Greeting(name: String) {\n2      Text(\"Hello $name\")\n3  }</pre>\nIs Greeting() a composable function?",
    "options": [
      "Yes",
      "No",
      "Maybe",
      "Only if called inside @Composable"
    ],
    "correct": 1,
    "why": "[Line 1] declares the function without the @Composable annotation. Even though [line 2] calls Text (a composable), the function itself is not composable without the annotation."
  },
  {
    "q": "<pre class=\"code-block\">1  @Composable\n2  fun CounterExample() {\n3      var count = 0\n4      Button(onClick = { count++ }) {\n5          Text(\"Count: $count\")\n6      }\n7  }</pre>\nWhat happens when the user clicks the button?",
    "options": [
      "Count increments and displays increasing numbers",
      "Count never changes because the variable is not remembered",
      "App crashes",
      "Button becomes disabled"
    ],
    "correct": 1,
    "why": "[Line 3] declares count without remember. [Line 4] increments it on click, triggering recomposition. Since count isn't remembered, [line 3] resets it to 0 on each recomposition, so [line 5] always displays \"Count: 0\"."
  },
  {
    "q": "<pre class=\"code-block\">1  @Composable\n2  fun CounterExample2() {\n3      var count by remember { mutableStateOf(0) }\n4      Button(onClick = { count++ }) {\n5          Text(\"Count: $count\")\n6      }\n7  }</pre>\nAfter pressing the button three times, what text is shown?",
    "options": [
      "Count: 3",
      "Count: 0",
      "Count: 1",
      "The app crashes"
    ],
    "correct": 0,
    "why": "[Line 3] uses remember with mutableStateOf to persist count across recompositions. [Line 4] increments count on each click. After three clicks, count = 3, and [line 5] displays \"Count: 3\"."
  },
  {
    "q": "<pre class=\"code-block\">1  Box(\n2      modifier = Modifier.size(100.dp).size(200.dp)\n3  ) {\n4      Text(\"Hello\")\n5  }</pre>\nWhat is the final size of the Box?",
    "options": [
      "100 dp",
      "200 dp",
      "300 dp",
      "It has zero size"
    ],
    "correct": 1,
    "why": "[Line 2] chains two size modifiers. When chaining modifiers, the last one wins. The second .size(200.dp) overrides the first .size(100.dp), so the Box is 200 dp."
  },
  {
    "q": "<pre class=\"code-block\">1  Scaffold(\n2      topBar = { TopAppBar(title = { Text(\"App\") }) },\n3      floatingActionButton = { FloatingActionButton(onClick = {}) { Text(\"FAB\") } }\n4  ) { innerPadding ->\n5      Text(\"Content\", modifier = Modifier.padding(innerPadding))\n6  }</pre>\nWhich slot places the floating action button?",
    "options": [
      "topBar",
      "floatingActionButton",
      "content",
      "drawerContent"
    ],
    "correct": 1,
    "why": "[Line 3] uses the floatingActionButton parameter to provide a FloatingActionButton. Scaffold provides specific named slots: topBar ([line 2]), floatingActionButton ([line 3]), and content ([lines 4-5])."
  },
  {
    "q": "<pre class=\"code-block\">1  navController.navigate(\"profile\")\n2  navController.navigate(\"settings\")\n3  navController.popBackStack()</pre>\nAfter executing these calls, where does the user end up?",
    "options": [
      "Still on Settings",
      "Back on Profile",
      "On the Home screen",
      "The entire stack is cleared"
    ],
    "correct": 1,
    "why": "[Line 1] navigates to profile, [line 2] navigates to settings (stack now has profile -> settings). [Line 3] calls popBackStack() which removes the top destination (settings), returning to profile."
  },
  {
    "q": "<pre class=\"code-block\">1  class CounterViewModel : ViewModel() {\n2      var count by mutableStateOf(0)\n3  }</pre>\nWhich statement about this ViewModel is true?",
    "options": [
      "The count persists across configuration changes",
      "The count resets on every recomposition",
      "ViewModel holds no state",
      "mutableStateOf is unnecessary"
    ],
    "correct": 0,
    "why": "[Line 1] declares a ViewModel which survives configuration changes like screen rotation. [Line 2] uses mutableStateOf to hold observable state. The count persists as long as the ViewModel exists."
  },
  {
    "q": "<pre class=\"code-block\">1  @Composable\n2  fun RememberDemo() {\n3      var text by remember { mutableStateOf(\"\") }\n4      TextField(value = text, onValueChange = { text = it })\n5  }</pre>\nWhat happens to the text when the device rotates?",
    "options": [
      "The text resets to empty",
      "The text persists",
      "The app crashes",
      "The text duplicates"
    ],
    "correct": 0,
    "why": "[Line 3] uses remember, which only persists state across recompositions, not configuration changes like rotation. The entire activity is recreated on rotation, so text resets to empty string."
  },
  {
    "q": "<pre class=\"code-block\">1  @Composable\n2  fun RememberSaveableDemo() {\n3      var text by rememberSaveable { mutableStateOf(\"\") }\n4      TextField(value = text, onValueChange = { text = it })\n5  }</pre>\nHow does this behave across a device rotation?",
    "options": [
      "The text is lost",
      "The text persists",
      "An exception is thrown",
      "The state is saved only if text is numeric"
    ],
    "correct": 1,
    "why": "[Line 3] uses rememberSaveable which saves state to the SavedInstanceState bundle. Unlike remember, rememberSaveable persists across configuration changes like rotation, so the text remains after rotation."
  },
  {
    "q": "<pre class=\"code-block\">1  @Composable\n2  fun ToggleExample() {\n3      var enabled by remember { mutableStateOf(true) }\n4      Switch(checked = enabled, onCheckedChange = { enabled = it })\n5  }</pre>\nWhat happens when the user toggles the switch?",
    "options": [
      "The enabled value updates and the UI reflects the change",
      "Nothing happens",
      "The switch toggles but state is not remembered",
      "The app crashes"
    ],
    "correct": 0,
    "why": "[Line 3] uses remember with mutableStateOf to track enabled state. [Line 4] binds the Switch to this state. When toggled, onCheckedChange updates enabled ([line 4]), triggering recomposition and updating the UI."
  },
  {
    "q": "<pre class=\"code-block\">1  @Composable\n2  fun StatelessToggle(enabled: Boolean, onToggle: (Boolean) -> Unit) {\n3      Switch(checked = enabled, onCheckedChange = onToggle)\n4  }\n5  @Composable\n6  fun Parent() {\n7      var enabled by remember { mutableStateOf(false) }\n8      StatelessToggle(enabled = enabled, onToggle = { enabled = it })\n9  }</pre>\nWhat pattern does this illustrate?",
    "options": [
      "State hoisting",
      "Two‑way data binding",
      "Stateful composable",
      "Global mutable state"
    ],
    "correct": 0,
    "why": "[Lines 2-4] define a stateless component that receives state as parameters. [Line 7] holds the state in the parent. [Line 8] passes state down and callbacks up. This is state hoisting - moving state to a common ancestor."
  }
];
    // --- Quiz Logic (DO NOT MODIFY) ---
    const quizEl = document.getElementById('quiz');
    const scoreEl = document.getElementById('score');
    const progressEl = document.getElementById('progress');
    const percentEl = document.getElementById('percent');
    const resetBtn = document.getElementById('resetBtn');
    const revealBtn = document.getElementById('revealBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    let state = { score: 0, answered: 0 };
    let currentQuestions = [];
    function shuffle(arr) {
      const copy = [...arr];
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }
    function buildQuestions() {
      return shuffle(QUESTIONS).map(q => (({
        q: q.q,
        options: shuffle(q.options.map((txt, i) => ({ txt, isCorrect: i === q.correct }))),
        correct: 0,
        why: q.why,
        __answered: false
      }))).map(item => {
        item.correct = item.options.findIndex(o => o.isCorrect);
        item.options = item.options.map(o => o.txt);
        return item;
      });
    }
    function render() {
      quizEl.innerHTML = '';
      currentQuestions.forEach((item, qi) => {
        const card = document.createElement('div');
        card.className = 'qcard';
        const head = document.createElement('div');
        head.className = 'qhead';
        const titleEl = document.createElement('p');
        titleEl.className = 'qtitle';
        // Render question text as HTML to support code snippets with <pre> tags
        titleEl.innerHTML = `${qi + 1}. ${item.q}`;
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = `Q${qi + 1}`;
        head.appendChild(titleEl);
        head.appendChild(badge);
        card.appendChild(head);
        const opts = document.createElement('div');
        opts.className = 'opts';
        item.options.forEach((opt, oi) => {
          const row = document.createElement('div');
          row.className = 'opt';
          row.setAttribute('data-q', qi);
          row.setAttribute('data-o', oi);
          const letter = document.createElement('div');
          letter.className = 'letter';
          letter.textContent = String.fromCharCode(65 + oi);
          const span = document.createElement('span');
          span.innerHTML = opt;
          row.appendChild(letter);
          row.appendChild(span);
          row.addEventListener('click', onChoose);
          opts.appendChild(row);
        });
        const exp = document.createElement('div');
        exp.className = 'exp';
        exp.hidden = true;
        exp.innerHTML = `<strong>Explanation:</strong> ${item.why}`;
        card.appendChild(opts);
        card.appendChild(exp);
        quizEl.appendChild(card);
      });
      updateStats();
    }
    function onChoose(e) {
      const btn = e.currentTarget;
      const qIndex = +btn.getAttribute('data-q');
      const oIndex = +btn.getAttribute('data-o');
      const card = btn.closest('.qcard');
      const exp = card.querySelector('.exp');
      const data = currentQuestions[qIndex];
      if (data.__answered) return;
      const options = card.querySelectorAll('.opt');
      options.forEach(b => b.classList.add('disabled'));
      data.__answered = true;
      state.answered++;
      if (oIndex === data.correct) {
        btn.classList.add('correct');
        state.score++;
      } else {
        btn.classList.add('wrong');
        options[data.correct].classList.add('correct');
      }
      exp.hidden = false;
      updateStats();
    }
    function updateStats() {
      scoreEl.textContent = `Score: ${state.score}`;
      progressEl.textContent = `Answered: ${state.answered} / ${currentQuestions.length}`;
      const pct = currentQuestions.length ? Math.round((state.score/currentQuestions.length)*100) : 0;
      percentEl.textContent = `${pct}%`;
    }
    function revealAll() {
      document.querySelectorAll('.qcard').forEach((card, qi) => {
        const data = currentQuestions[qi];
        const exp = card.querySelector('.exp');
        const options = card.querySelectorAll('.opt');
        options.forEach((b, oi) => {
          b.classList.remove('wrong');
          if (oi === data.correct) b.classList.add('correct');
          b.classList.add('disabled');
        });
        data.__answered = true;
        exp.hidden = false;
      });
    }
    function resetQuiz() {
      state.score = 0; state.answered = 0;
      render();
    }
    function shuffleQuiz() {
      state.score = 0; state.answered = 0;
      currentQuestions = buildQuestions();
      render();
    }
    resetBtn.addEventListener('click', resetQuiz);
    revealBtn.addEventListener('click', revealAll);
    shuffleBtn.addEventListener('click', shuffleQuiz);
    currentQuestions = buildQuestions();
    render();
  </script>
</body>
</html>
